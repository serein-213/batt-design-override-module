name: Build batt_design_override (Auto GKI Fetch)

on:
  workflow_dispatch:
    inputs:
      kernel_lines:
        description: '内核主线列表: 5.4,5.10,5.15,6.1 (空=全部)'
        required: false
        default: ''
      version:
        description: '模块版本号 (空=module.prop)'
        required: false
        default: ''
      release:
        description: '发布 Release (true/false)'
        required: false
        default: 'false'
      refresh_sources:
        description: '强制刷新 GKI 源码缓存 (true/false)'
        required: false
        default: 'false'
      custom_repo_url:
        description: '自定义内核源码仓库 (可选, 例如 https://github.com/xxx/kernel.git)'
        required: false
        default: ''
      custom_ref:
        description: '自定义仓库分支/标签 (与 custom_repo_url 搭配)'
        required: false
        default: ''

jobs:
  build:
    runs-on: ubuntu-22.04
    outputs:
      version: ${{ steps.ver.outputs.version }}
    strategy:
      fail-fast: false
      matrix:
        kernel_line: ["5.4", "5.10", "5.15", "6.1"]
    env:
      MODULE_ID: batt-design-override
      MAGISK_DIR: packaging/magisk-batt-design-override
      CCACHE_DIR: ${{ github.workspace }}/.ccache
      ARCH: arm64
      LLVM: 1
      LLVM_IAS: 1
      JOBS: 8
      LTO_JOBS: 8
    steps:
      - uses: actions/checkout@v4
      - name: 过滤所需内核
        id: filter
        run: |
          REQ='${{ github.event.inputs.kernel_lines }}'
          if [[ -z "$REQ" ]]; then B=1; else
            WANT=$(echo "$REQ" | tr ' ' ',' | sed 's/,,*/,/g' | sed 's/^,//;s/,$//')
            IFS=',' read -r -a ARR <<< "$WANT"; B=0; for k in "${ARR[@]}"; do [[ "$k" == "${{ matrix.kernel_line }}" ]] && B=1; done
          fi
          echo "build=$B" >> $GITHUB_OUTPUT
      - name: 跳过标记
        if: steps.filter.outputs.build != '1'
        run: echo "Skip ${{ matrix.kernel_line }}"
      - name: 安装依赖
        if: steps.filter.outputs.build == '1'
        run: |
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends cpio libelf-dev bc flex bison python3 rsync build-essential zip unzip file jq git lld clang llvm llvm-dev llvm-runtime
          echo "[i] Host clang:"; clang --version || true
          echo "[i] Host ld.lld path:"; command -v ld.lld || true
          # 某些 runner 镜像可能只有 /usr/lib/llvm-*/bin/ld.lld 未放入 PATH
          if ! command -v ld.lld >/dev/null 2>&1; then
            FOUND=$(command -v /usr/lib/llvm-*/bin/ld.lld 2>/dev/null | head -n1 || true)
            if [[ -n "$FOUND" ]]; then sudo ln -sf "$FOUND" /usr/local/bin/ld.lld; fi
          fi
          if ! command -v ld.lld >/dev/null 2>&1; then echo "::error ::仍未找到 ld.lld"; exit 2; fi
      - name: 分支候选 (准备)
        if: steps.filter.outputs.build == '1'
        id: branch_select
        run: |
          case "${{ matrix.kernel_line }}" in
            5.4)  CANDIDATES=(android11-5.4 android12-5.10 android-mainline); OUT=gki/out-5.4 ;;
            5.10) CANDIDATES=(android12-5.10 android13-5.10 android-mainline); OUT=gki/out-5.10 ;;
            5.15) CANDIDATES=(android13-5.15 android14-6.1 android-mainline); OUT=gki/out-5.15 ;;
            6.1)  CANDIDATES=(android14-6.1 android-mainline); OUT=gki/out-6.1 ;;
            *) echo '未知 kernel_line' >&2; exit 2;;
          esac
          mkdir -p gki "$OUT"
          echo "candidates=${CANDIDATES[*]}" >> $GITHUB_OUTPUT
          echo "out=$OUT" >> $GITHUB_OUTPUT
          echo "[i] 候选分支: ${CANDIDATES[*]}"
      - name: 选择并克隆分支
        if: steps.filter.outputs.build == '1'
        id: fetch_kernel
        run: |
          set -e
          CANDIDATES='${{ steps.branch_select.outputs.candidates }}'
          CUSTOM_URL='${{ github.event.inputs.custom_repo_url }}'
          CUSTOM_REF='${{ github.event.inputs.custom_ref }}'
          if [[ -n "$CUSTOM_URL" && -n "$CUSTOM_REF" ]]; then
            echo "[i] 使用自定义仓库: $CUSTOM_URL @ $CUSTOM_REF"
            git clone --depth=1 --branch "$CUSTOM_REF" "$CUSTOM_URL" gki/custom-src
            SELECTED="$CUSTOM_REF"; SRC_PATH="gki/custom-src"
          else
            SELECTED=""
            for cand in $CANDIDATES; do
              echo "[i] 尝试分支: $cand"
              if [[ -d gki/$cand && -f gki/$cand/Makefile ]]; then
                SELECTED="$cand"; SRC_PATH="gki/$cand"; break
              fi
              rm -rf gki/tmp-clone
              git clone --depth=1 --branch "$cand" https://android.googlesource.com/kernel/common gki/tmp-clone 2>/dev/null || continue
              mv gki/tmp-clone gki/$cand
              SELECTED="$cand"; SRC_PATH="gki/$cand"; break
            done
          fi
          if [[ -z "$SELECTED" ]]; then
            echo "::error ::未能匹配任何有效分支 ($CANDIDATES)，可提供 custom_repo_url+custom_ref"; exit 2
          fi
          echo "branch=$SELECTED" >> $GITHUB_OUTPUT
          echo "src=$SRC_PATH" >> $GITHUB_OUTPUT
          echo "out=${{ steps.branch_select.outputs.out }}" >> $GITHUB_OUTPUT
          echo "[i] 已选择: $SELECTED -> $SRC_PATH"
      - name: 强制刷新源码 (可选)
        if: steps.filter.outputs.build == '1' && github.event.inputs.refresh_sources == 'true'
        run: |
          SRC='${{ steps.fetch_kernel.outputs.src }}'
          BR='${{ steps.fetch_kernel.outputs.branch }}'
          if [[ "$SRC" == gki/custom-src ]]; then
            echo "[i] 自定义仓库不自动刷新"
          else
            echo "[i] 刷新 $BR"
            rm -rf "$SRC"
            git clone --depth=1 --branch "$BR" https://android.googlesource.com/kernel/common "$SRC"
          fi
      - name: 生成元数据 (日期+模块哈希)
        if: steps.filter.outputs.build == '1'
        id: meta
        run: |
          DATE_TAG=$(date +%Y%m%d)
          MOD_HASH=$( (sha256sum extra_modules/batt_design_override/*.c 2>/dev/null; sha256sum extra_modules/batt_design_override/Makefile) | sha256sum | cut -d' ' -f1 )
          echo "date=$DATE_TAG" >> $GITHUB_OUTPUT
          echo "mod_hash=$MOD_HASH" >> $GITHUB_OUTPUT
          echo "::notice title=ModuleHash::$MOD_HASH"
      - name: 缓存源码
        if: steps.filter.outputs.build == '1'
        uses: actions/cache@v4
        with:
          path: ${{ steps.fetch_kernel.outputs.src }}
          key: src-${{ steps.fetch_kernel.outputs.branch }}-${{ steps.meta.outputs.date }}
          restore-keys: |
            src-${{ steps.fetch_kernel.outputs.branch }}-
      - name: 缓存 out
        if: steps.filter.outputs.build == '1'
        uses: actions/cache@v4
        with:
          path: ${{ steps.fetch_kernel.outputs.out }}
          key: out-${{ steps.fetch_kernel.outputs.branch }}-${{ steps.meta.outputs.date }}-${{ steps.meta.outputs.mod_hash }}
          restore-keys: |
            out-${{ steps.fetch_kernel.outputs.branch }}-${{ steps.meta.outputs.date }}-
            out-${{ steps.fetch_kernel.outputs.branch }}-
      - name: 缓存 ccache
        if: steps.filter.outputs.build == '1'
        uses: actions/cache@v4
        with:
          path: .ccache
          key: ccache-${{ steps.fetch_kernel.outputs.branch }}-${{ steps.meta.outputs.mod_hash }}
          restore-keys: |
            ccache-${{ steps.fetch_kernel.outputs.branch }}-
      - name: 构建模块
        if: steps.filter.outputs.build == '1'
        run: |
          set -e
          KERNEL_SRC='${{ steps.fetch_kernel.outputs.src }}'
          KERNEL_OUT='${{ steps.fetch_kernel.outputs.out }}'
          ARCH=arm64
          CROSS_COMPILE=aarch64-linux-gnu-
          CLANG_TRIPLE=aarch64-linux-gnu-
          export LLVM=1 LLVM_IAS=1 ARCH CROSS_COMPILE CLANG_TRIPLE
          echo "[dbg] ENV ARCH=$ARCH CROSS_COMPILE=$CROSS_COMPILE CLANG_TRIPLE=$CLANG_TRIPLE LLVM=$LLVM LLVM_IAS=$LLVM_IAS"
          clang --version | head -n1 || true
          if ! command -v ld.lld >/dev/null 2>&1; then echo "::error ::缺少 ld.lld"; exit 2; fi
          
          # 生成 .config
          if [[ ! -f "$KERNEL_OUT/.config" ]]; then
            if ! make -C "$KERNEL_SRC" O="$KERNEL_OUT" ARCH=$ARCH LLVM=1 LLVM_IAS=1 \
              CC=clang LD=ld.lld CLANG_TRIPLE=$CLANG_TRIPLE CROSS_COMPILE=$CROSS_COMPILE \
              LLVM_AR=llvm-ar LLVM_NM=llvm-nm LLVM_OBJCOPY=llvm-objcopy LLVM_OBJDUMP=llvm-objdump \
              READELF=llvm-readelf STRIP=llvm-strip gki_defconfig; then
              echo "::group::可用 *gki* defconfig 列表"; ls "$KERNEL_SRC"/arch/arm64/configs/*gki* 2>/dev/null || true; echo "::endgroup::";
              echo "::error ::gki_defconfig 失败 (branch='${{ steps.fetch_kernel.outputs.branch }}')"; exit 2; fi
          else
            echo "[i] 发现现有 .config -> olddefconfig";
            make -C "$KERNEL_SRC" O="$KERNEL_OUT" ARCH=$ARCH LLVM=1 LLVM_IAS=1 \
              CC=clang LD=ld.lld CLANG_TRIPLE=$CLANG_TRIPLE CROSS_COMPILE=$CROSS_COMPILE \
              LLVM_AR=llvm-ar LLVM_NM=llvm-nm LLVM_OBJCOPY=llvm-objcopy LLVM_OBJDUMP=llvm-objdump \
              READELF=llvm-readelf STRIP=llvm-strip olddefconfig
          fi
          
          # 禁用 IKHEADERS (缺少 cpio 时)
          if ! command -v cpio >/dev/null 2>&1; then
            echo "[i] 未检测到 cpio，禁用 CONFIG_IKHEADERS"
            if grep -q '^CONFIG_IKHEADERS=' "$KERNEL_OUT/.config"; then
              sed -i 's/^CONFIG_IKHEADERS=.*/# CONFIG_IKHEADERS is not set/' "$KERNEL_OUT/.config"
            else
              echo '# CONFIG_IKHEADERS is not set' >> "$KERNEL_OUT/.config"
            fi
            make -C "$KERNEL_SRC" O="$KERNEL_OUT" ARCH=$ARCH LLVM=1 LLVM_IAS=1 \
              CC=clang LD=ld.lld CLANG_TRIPLE=$CLANG_TRIPLE CROSS_COMPILE=$CROSS_COMPILE \
              LLVM_AR=llvm-ar LLVM_NM=llvm-nm LLVM_OBJCOPY=llvm-objcopy LLVM_OBJDUMP=llvm-objdump \
              READELF=llvm-readelf STRIP=llvm-strip olddefconfig
          fi
          
          # 确保 Module.symvers 存在
          if [[ ! -f "$KERNEL_OUT/Module.symvers" ]]; then
            echo "[i] 未发现 Module.symvers，执行 make modules"
            make -C "$KERNEL_SRC" O="$KERNEL_OUT" ARCH=$ARCH LLVM=1 LLVM_IAS=1 \
              CC=clang LD=ld.lld CLANG_TRIPLE=$CLANG_TRIPLE CROSS_COMPILE=$CROSS_COMPILE \
              LLVM_AR=llvm-ar LLVM_NM=llvm-nm LLVM_OBJCOPY=llvm-objcopy LLVM_OBJDUMP=llvm-objdump \
              READELF=llvm-readelf STRIP=llvm-strip \
              -j$(nproc) modules
          fi
          
          # ThinLTO 配置 (参考本地脚本)
          if grep -q '^CONFIG_LTO_CLANG_THIN=y' "$KERNEL_OUT/.config" 2>/dev/null; then
            LTO_JOBS=$(nproc)
            export KBUILD_LDFLAGS="${KBUILD_LDFLAGS:-} -Wl,-plugin-opt,jobs=${LTO_JOBS}"
            echo "[i] 检测到 ThinLTO -> LTO_JOBS=$LTO_JOBS"
          fi
          
          # 创建编译器 wrapper (关键修复)
          WRAP_DIR=$(mktemp -d)
          cat >"$WRAP_DIR/clang-wrapper" <<'EOF'
#!/usr/bin/env bash
ARGS=()
SEEN_TRIVIAL=0
for a in "$@"; do
  # 移除空对齐 flag
  if [[ "$a" == -falign-functions= ]]; then
    continue
  fi
  if [[ "$a" == -ftrivial-auto-var-init=zero ]]; then
    SEEN_TRIVIAL=1
  fi
  ARGS+=("$a")
done
# 处理 trivial-auto-var-init
if [[ $SEEN_TRIVIAL -eq 1 ]]; then
  HAVE_ENABLE=0
  for x in "${ARGS[@]}"; do
    [[ "$x" == -enable-trivial-auto-var-init-zero-knowing-it-will-be-removed-from-clang ]] && HAVE_ENABLE=1 && break
  done
  if [[ $HAVE_ENABLE -eq 0 ]]; then
    ARGS+=("-enable-trivial-auto-var-init-zero-knowing-it-will-be-removed-from-clang")
  fi
else
  ARGS+=("-enable-trivial-auto-var-init-zero-knowing-it-will-be-removed-from-clang" "-ftrivial-auto-var-init=zero")
fi
CLANG_BIN=$(command -v clang || true)
exec "$CLANG_BIN" "${ARGS[@]}"
EOF
          chmod +x "$WRAP_DIR/clang-wrapper"
          export CC="$WRAP_DIR/clang-wrapper"
          export HOSTCC=clang
          echo "[i] 启用编译器 wrapper: $CC"
          
          # 设置 KCFLAGS (重要)
          EXTRA_KCFLAGS="-Wno-macro-redefined"
          
          # 使用绝对路径的 M
          MOD_DIR_ABS=$(pwd)/extra_modules/batt_design_override
          if [[ ! -f "$MOD_DIR_ABS/Makefile" ]]; then
            echo "::error ::模块 Makefile 不存在: $MOD_DIR_ABS/Makefile"; ls -l "$MOD_DIR_ABS" || true; exit 2
          fi
          echo "[i] 使用外部模块目录: $MOD_DIR_ABS"
          
          # 构建模块 (使用本地脚本的参数)
          make -C "$KERNEL_SRC" O="$KERNEL_OUT" ARCH=$ARCH LLVM=1 LLVM_IAS=1 \
            CC="$CC" HOSTCC="$HOSTCC" LD=ld.lld CLANG_TRIPLE=$CLANG_TRIPLE CROSS_COMPILE=$CROSS_COMPILE \
            LLVM_AR=llvm-ar LLVM_NM=llvm-nm LLVM_OBJCOPY=llvm-objcopy LLVM_OBJDUMP=llvm-objdump \
            READELF=llvm-readelf STRIP=llvm-strip KCFLAGS="$EXTRA_KCFLAGS" \
            M="$MOD_DIR_ABS" -j$(nproc) modules
          test -f "$MOD_DIR_ABS/batt_design_override.ko"
      - name: 构建 chg 模块
        if: steps.filter.outputs.build == '1'
        run: |
          set -e
          KERNEL_SRC='${{ steps.fetch_kernel.outputs.src }}'
          KERNEL_OUT='${{ steps.fetch_kernel.outputs.out }}'
          ARCH=arm64
          CROSS_COMPILE=aarch64-linux-gnu-
          CLANG_TRIPLE=aarch64-linux-gnu-
          export LLVM=1 LLVM_IAS=1 ARCH CROSS_COMPILE CLANG_TRIPLE
          
          # 重用编译器 wrapper
          WRAP_DIR=$(mktemp -d)
          cat >"$WRAP_DIR/clang-wrapper" <<'EOF'
#!/usr/bin/env bash
ARGS=()
SEEN_TRIVIAL=0
for a in "$@"; do
  [[ "$a" == -falign-functions= ]] && continue
  [[ "$a" == -ftrivial-auto-var-init=zero ]] && SEEN_TRIVIAL=1
  ARGS+=("$a")
done
if [[ $SEEN_TRIVIAL -eq 1 ]]; then
  HAVE_ENABLE=0
  for x in "${ARGS[@]}"; do
    [[ "$x" == -enable-trivial-auto-var-init-zero-knowing-it-will-be-removed-from-clang ]] && HAVE_ENABLE=1 && break
  done
  [[ $HAVE_ENABLE -eq 0 ]] && ARGS+=("-enable-trivial-auto-var-init-zero-knowing-it-will-be-removed-from-clang")
else
  ARGS+=("-enable-trivial-auto-var-init-zero-knowing-it-will-be-removed-from-clang" "-ftrivial-auto-var-init=zero")
fi
CLANG_BIN=$(command -v clang || true)
exec "$CLANG_BIN" "${ARGS[@]}"
EOF
          chmod +x "$WRAP_DIR/clang-wrapper"
          export CC="$WRAP_DIR/clang-wrapper"
          export HOSTCC=clang
          
          EXTRA_KCFLAGS="-Wno-macro-redefined"
          MOD_DIR_ABS=$(pwd)/extra_modules/chg_param_override
          if [[ ! -f "$MOD_DIR_ABS/Makefile" ]]; then
            echo "::error ::模块 Makefile 不存在: $MOD_DIR_ABS/Makefile"; exit 2
          fi
          echo "[i] 使用外部模块目录: $MOD_DIR_ABS"
          make -C "$KERNEL_SRC" O="$KERNEL_OUT" ARCH=$ARCH LLVM=1 LLVM_IAS=1 \
            CC="$CC" HOSTCC="$HOSTCC" LD=ld.lld CLANG_TRIPLE=$CLANG_TRIPLE CROSS_COMPILE=$CROSS_COMPILE \
            LLVM_AR=llvm-ar LLVM_NM=llvm-nm LLVM_OBJCOPY=llvm-objcopy LLVM_OBJDUMP=llvm-objdump \
            READELF=llvm-readelf STRIP=llvm-strip KCFLAGS="$EXTRA_KCFLAGS" \
            M="$MOD_DIR_ABS" -j$(nproc) modules
          test -f "$MOD_DIR_ABS/chg_param_override.ko"
      - name: 解析版本号
        if: steps.filter.outputs.build == '1'
        id: ver
        run: |
          BASE_VER=$(grep -E '^version=' packaging/magisk-batt-design-override/module.prop | cut -d= -f2-)
          if [[ -n "${{ github.event.inputs.version }}" ]]; then
            VER='${{ github.event.inputs.version }}'
          else
            VER="$BASE_VER"
          fi
          echo VERSION=$VER >> $GITHUB_ENV
          echo "version=$VER" >> $GITHUB_OUTPUT
      - name: 打包 Magisk 模块
        if: steps.filter.outputs.build == '1'
        run: |
          mkdir -p dist
          # 拷入两个 .ko，便于脚本整体打包
          mkdir -p packaging/magisk-batt-design-override/common
          cp -f extra_modules/batt_design_override/batt_design_override.ko packaging/magisk-batt-design-override/common/ || true
          cp -f extra_modules/chg_param_override/chg_param_override.ko packaging/magisk-batt-design-override/common/ || true
          bash packaging/build_magisk_zip.sh \
            --ko extra_modules/batt_design_override/batt_design_override.ko \
            --kernel-line ${{ matrix.kernel_line }} \
            --version $VERSION \
            --output dist
          ls -l dist
      - name: 准备发布文件（重命名 .ko/.apk 避免冲突）
        if: steps.filter.outputs.build == '1'
        run: |
          set -e
          ANDROID_TAG='${{ steps.fetch_kernel.outputs.branch }}'
          mkdir -p release_out
          if [ -f extra_modules/batt_design_override/batt_design_override.ko ]; then
            cp -f extra_modules/batt_design_override/batt_design_override.ko "release_out/batt_design_override-${ANDROID_TAG}.ko"
          fi
          if [ -f extra_modules/chg_param_override/chg_param_override.ko ]; then
            cp -f extra_modules/chg_param_override/chg_param_override.ko "release_out/chg_param_override-${ANDROID_TAG}.ko"
          fi
          # APK 不区分安卓版本：仅在 5.15 这一分支产出一次，避免重复文件名
          if [ -f packaging/magisk-batt-design-override/common/battcaplsp.apk ]; then
            if [ "${{ matrix.kernel_line }}" = "5.15" ]; then
              cp -f packaging/magisk-batt-design-override/common/battcaplsp.apk "release_out/battcaplsp.apk"
            fi
          fi
      - name: 上传构件
        if: steps.filter.outputs.build == '1'
        uses: actions/upload-artifact@v4
        with:
          name: batt-design-override-${{ matrix.kernel_line }}
          path: |
            release_out/*
            dist/*.zip
          if-no-files-found: error

  release:
    needs: build
    if: >-
      (github.event_name == 'workflow_dispatch' && inputs.release == 'true')
    runs-on: ubuntu-22.04
    permissions:
      contents: write
    steps:
      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          path: collected
      - name: Generate notes
        run: |
          echo "Release battmod-$(date +%Y%m%d-%H%M%S)" > NOTES.md
          find collected -name '*.zip' -printf '* %f\n' >> NOTES.md || true
      - name: Create Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.build.outputs.version }}
          name: ${{ needs.build.outputs.version }}
          body_path: NOTES.md
          files: |
            collected/**/dist/*.zip
            collected/**/release_out/*
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
